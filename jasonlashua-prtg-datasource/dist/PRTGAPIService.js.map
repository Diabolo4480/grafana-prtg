{"version":3,"sources":["../src/PRTGAPIService.js"],"names":["PRTGAPIService","alertSrv","backendSrv","PRTGAPI","api_url","username","passhash","cacheTimeoutMinutes","url","lastId","cache","Date","now","hashValue","Promise","resolve","data","getCache","str","hash","length","i","char","charCodeAt","a","slice","unixtime","d","s","getFullYear","pad","getMonth","getDate","getHours","getMinutes","getSeconds","join","method","params","queryString","options","inCache","setCache","datasourceRequest","then","response","reject","message","histdata","groups","devices","sensors","channels","values","sensordata","messages","Version","XMLXform","err","match","regex","res","exec","performPRTGAPIRequest","groupName","deviceId","sensorId","device","arr","p","_","map","getDeviceByName","sensor","getSensorByName","all","objid","name","concat","channelId","dateFrom","dateTo","deviceObj","e","sensorObj","hours","avg","getPRTGDate","results","lastmessage","timestamp","lastcheck","replace","dt","Math","round","result","rCnt","item","v","datetime_raw","value_raw","j","channel","Number","text","push","from","to","events","time","each","title","status","parent","type","angular","module","factory"],"mappings":"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","file":"PRTGAPIService.js","sourcesContent":["import angular from 'angular';\r\nimport _ from 'lodash';\r\nimport { XMLXform } from './xmlparser';\r\n/**\r\n * PRTG API Service\r\n * Implements the high level functions that process data from PRTG\r\n */\r\n\r\n/** @ngInject */\r\nfunction PRTGAPIService(alertSrv, backendSrv) {\r\n    \r\n    class PRTGAPI {\r\n        constructor (api_url, username, passhash, cacheTimeoutMinutes) {\r\n          this.url              = api_url;\r\n          this.username         = username;\r\n          this.passhash         = passhash;\r\n          this.lastId           = false;\r\n          this.cache            = {};\r\n          this.cacheTimeoutMinutes = cacheTimeoutMinutes;\r\n          this.alertSrv         = alertSrv;\r\n          this.backendSrv       = backendSrv;\r\n          \r\n        }\r\n        \r\n        /**\r\n         * Tests whether a url has been stored in the cache.\r\n         * Returns boolean true | false\r\n         */\r\n        inCache(url) {\r\n            if ((Date.now() - this.cache[this.hashValue(url)]) > (this.cacheTimeoutMinutes * 60 * 1000)) {\r\n                return false;\r\n            }\r\n            if (this.cache[this.hashValue(url)]) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        \r\n        /**\r\n        * retrieves a cached data result from the cache\r\n        *\r\n        * @param  url the URL of the request\r\n        * @return promise\r\n        */\r\n        getCache(url)    {\r\n            return Promise.resolve(this.cache[this.hashValue(url)]);\r\n        }\r\n        \r\n        /**\r\n        * stores a data result in the cache\r\n        *\r\n        * @param  url the URL of the request\r\n        * @param  data the response.data object of the request\r\n        * @return promise\r\n        */\r\n        setCache(url, data)    {\r\n            this.cache[this.hashValue(url)] = data;\r\n            return this.getCache(url);\r\n        }\r\n        \r\n        /**\r\n        * simple clone of a java hash value\r\n        * Kevin \"Pancake\" (http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/)\r\n        *\r\n        * @param  e string to hash\r\n        * @return int32\r\n        */\r\n        hashValue(str) {\r\n            var hash = 0;\r\n            if (str.length === 0) return hash;\r\n            for (var i = 0; i < str.length; i++) {\r\n                var char = str.charCodeAt(i);\r\n                hash = ((hash<<5)-hash)+char;\r\n                hash = hash & hash; // Convert to 32bit integer\r\n            }\r\n            return hash;\r\n        }\r\n        \r\n        /**\r\n         * pad date parts and optionally add one\r\n         */\r\n        pad(i,a)\t{\r\n            if (a) return (\"0\" + (i + 1)).slice(-2);\r\n            return (\"0\" + i).slice(-2);\r\n        }\r\n        \r\n        /**\r\n        * convert a UNIX timestamp into a PRTG date string for queries\r\n        * YYYY-MM-DD-HH-MM-SS\r\n        */\r\n        getPRTGDate(unixtime) \t{\r\n            var d = new Date(unixtime * 1000);\r\n            var s = [d.getFullYear(), this.pad(d.getMonth(),true), this.pad(d.getDate()), this.pad(d.getHours()), this.pad(d.getMinutes()), this.pad(d.getSeconds())];\r\n            //console.log(\"date string: \" + s.join(\"-\"));\r\n            return s.join(\"-\");\r\n        }\r\n\t\r\n        /**\r\n         * Request data from PRTG API\r\n         *\r\n         * @param  method the API method (e.g., table.json)\r\n         * @param  params HTTP query string query parameters\r\n         * @return promise\r\n         */\r\n        performPRTGAPIRequest(method, params) {\r\n            var queryString = 'username=' + this.username + '&passhash=' + this.passhash + '&' + params;\r\n            var options = {\r\n                method: 'GET',\r\n                url: this.url + '/' + method + '?' + queryString\r\n            };\r\n            \r\n            if (this.inCache(options.url)) {\r\n              return this.getCache(options.url);\r\n            } else {\r\n              return this.setCache(options.url, this.backendSrv.datasourceRequest(options)\r\n                .then(response => {\r\n                    if (!response.data) {\r\n                        return Promise.reject({message: \"Response contained no data\"});\r\n                    } \r\n                    if (response.data.histdata) {\r\n                        return response.data;\r\n                    }\r\n                    else if (response.data.groups) {\r\n                      return response.data.groups;\r\n                    }\r\n                    else if (response.data.devices) {\r\n                      return response.data.devices;\r\n                    }\r\n                    else if (response.data.sensors) {\r\n                      return response.data.sensors;\r\n                    }\r\n                    else if (response.data.channels) {\r\n                      return response.data.channels;\r\n                    }\r\n                    else if (response.data.values) {\r\n                      return response.data.values;\r\n                    }\r\n                    else if (response.data.sensordata) {\r\n                      return response.data.sensordata;\r\n                    }\r\n                    else if (response.data.messages) {\r\n                      return response.data.messages;\r\n                    }\r\n                    else if (response.data.Version) { //status request\r\n                      return response.data;\r\n                    } else {  //All else is XML from table.xml so throw it into the transformer and get JSON back.\r\n                      if (response.data == \"Not enough monitoring data\") {\r\n                        //Fixes Issue #5 - reject the promise with a message. The message is displayed instead of an uncaught exception.\r\n                        return Promise.reject({message: \"<p style=\\\"font-size: 150%; font-weight: bold\\\">Not enough monitoring data.</p><p>Request:<br> &quot;\" + params + \"&quot;</p>\"});\r\n                      }\r\n                      return new XMLXform(method, response.data);\r\n                    }\r\n              }, err => {\r\n                if (err.data.match(/<error>/g)) {\r\n                  var regex = /<error>(.*)<\\/error>/g;\r\n                  var res = regex.exec(err.data);\r\n                  err.message = res[1];\r\n                } else {\r\n                  err.message = \"Unknown error: \" + err.data;\r\n                }\r\n                return Promise.reject(err);\r\n              }));\r\n            }   \r\n        }\r\n    \r\n        getVersion() {\r\n            return this.performPRTGAPIRequest('status.json').then(function (response) {\r\n                if (!response)\r\n                {\r\n                  return \"ERROR. No response.\";\r\n                } else {\r\n                  return response.Version;\r\n                }\r\n            });\r\n        }\r\n    \r\n        /**\r\n         * Authenticate to the PRTG interface\r\n         * not implemented yet (pass username/pass as query string/POST data)\r\n         */\r\n        performPRTGAPILogin() {\r\n            var username = this.username;\r\n            var passhash = this.passhash;\r\n            var options = {\r\n                method: 'GET',\r\n                url: this.url + \"/getstatus.htm?id=0&username=\" + username + \"&passhash=\" + passhash\r\n            };\r\n            return this.backendSrv.datasourceRequest(options).then(response => {\r\n                this.passhash = response;\r\n                return response;\r\n            });\r\n        }\r\n    \r\n        /**\r\n         * Query API for list of groups\r\n         *\r\n         * @return promise - JSON result set\r\n         */\r\n        performGroupSuggestQuery() {\r\n            var params = 'content=groups&columns=objid,group';\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n    \r\n        /**\r\n         * Query API for list of devices\r\n         *\r\n         * @return promise - JSON result set\r\n         */\r\n        performDeviceSuggestQuery(groupName) {\r\n            var params = 'content=devices&columns=objid,device';\r\n            if (groupName) {\r\n                params += ',group&filter_group=' + groupName;\r\n            }\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n    \r\n        /**\r\n         * Query API for list of sensors bound to a given device\r\n         *\r\n         * @return promise - JSON result set\r\n         */\r\n        performSensorSuggestQuery(deviceId) {\r\n            var params = 'content=sensors&columns=objid,sensor,device,group&filter_device=' + deviceId;\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n    \r\n        /**\r\n         * Query API for list of channels bound to a given sensor\r\n         * the sensor Id is unique to each device\r\n         *\r\n         * @return promise - JSON result set\r\n         */\r\n        performChannelSuggestQuery(sensorId, device) {\r\n            var arr = [{\"device\": device}, {\"sensor\":sensorId}];\r\n            var p = [];\r\n            p = _.map(arr, a => {\r\n                if (a.device && typeof a.device == \"string\") {\r\n                     return this.getDeviceByName(a.device);\r\n                }\r\n                \r\n                if (a.sensor && typeof a.sensor == \"string\") {\r\n                    return this.getSensorByName(a.sensor,arr[0].device);\r\n                }\r\n                \r\n            });\r\n            \r\n            return Promise.all(p).then(a => {\r\n                var sensor = a[1][0].objid;\r\n                var params = 'content=channels&columns=objid,channel,sensor,name&id=' + sensor;\r\n                return this.performPRTGAPIRequest('table.json', params);\r\n            });\r\n        }\r\n    \r\n        /**\r\n         *  For Templating: Retrieve device ObjId by it's name.\r\n         */\r\n        getDeviceByName(name)    {\r\n            var params = 'content=devices&columns=objid,device&filter_device=' + name;\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n\r\n        /**\r\n         *  For Templating: Retrieve Sensor ObjId by it's name and parent device ObjId\r\n         */\r\n        getSensorByName(name, device)    {\r\n            var params = 'content=sensors&columns=objid,device,sensor&id=' + device + '&filter_sensor=' + name;\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n    \r\n        /**\r\n         * For templating: Retrieve Channel id from its given name.\r\n         * Sensor ID (number) required.\r\n         */\r\n        getChannelByName(name, sensor) {\r\n            var params = 'content=channels&columns=objid,channel,channelid&id='+ sensor;\r\n            if (name !== \"*\") {\r\n                params = params.concat('&filter_channel=' + name);\r\n            }\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n    \r\n        /**\r\n         * Query API for data of a given sensorId and then return the\r\n         * matching channel data\r\n         * @param deviceId Name of Device\r\n         * @param  sensorId Name of Sensor\r\n         * @param  channelId Name of Channel\r\n         * @param dateFrom  Earliest time in range\r\n         * @param dateTo Latest time in range\r\n         * @return array\r\n         */\r\n        getValues(deviceId, sensorId, channelId, dateFrom, dateTo) {\r\n            return this.getDeviceByName(deviceId).then(deviceObj => {\r\n                var device;\r\n                try {\r\n                    device = deviceObj[0].objid;\r\n                } catch (e) {\r\n                    return [];\r\n                }       \r\n                return this.getSensorByName(sensorId, device).then(sensorObj => {\r\n                    var sensor = sensorObj[0].objid;\r\n                    var hours = ((dateTo-dateFrom) / 3600);\r\n                    var avg = 0;\r\n                    if (hours > 12 && hours < 36) {\r\n                        avg = \"300\";\r\n                    } else if (hours > 36 && hours < 745) {\r\n                        avg = \"3600\";\r\n                    } else if (hours > 745) {\r\n                        avg = \"86400\";\r\n                    }\r\n                \r\n                    var method = \"historicdata.json\";\r\n                    var params = \"usecaption=true&id=\" + sensor + \"&sdate=\" + this.getPRTGDate(dateFrom) + \"&edate=\" + this.getPRTGDate(dateTo) + \"&avg=\" + avg + \"&pctshow=false&pctmode=false\";\r\n            \r\n                    if (channelId == '!') {\r\n                        params = \"&id=\" + sensor;\r\n                        return this.performPRTGAPIRequest('getsensordetails.json', params).then(results => {\r\n                            var message = results.lastmessage;\r\n                            var timestamp = results.lastcheck.replace(/(\\s\\[[\\d\\smsago\\]]+)/g,'');\r\n                            var dt = Math.round((timestamp - 25569) * 86400,0) * 1000;\r\n                            return [message, dt];\r\n                        });\r\n                    } else {\r\n                        return this.performPRTGAPIRequest(method, params).then(results => {\r\n                            var result = [];\r\n                            if (!results.histdata) {\r\n                                return results;\r\n                            }\r\n                            var rCnt = results.histdata.item.length;\r\n        \r\n                            for (var i=0;i<rCnt;i++)\r\n                            {\r\n                                var v;\r\n                                var dt = Math.round((results.histdata.item[i].datetime_raw - 25569) * 86400,0) * 1000;\r\n                                if (results.histdata.item[i].value_raw && (results.histdata.item[i].value_raw.length > 0))\r\n                                {\r\n                                    //FIXME: better way of dealing with multiple channels of same name\r\n                                    //IE you select \"Traffic In\" but PRTG provides Volume AND Speed channels.\r\n                                    for (var j = 0; j < results.histdata.item[i].value_raw.length; j++) {\r\n                                      //workaround for SNMP Bandwidth Issue #3. Check for presence of (speed) suffix, and use that.\r\n                                      if (results.histdata.item[i].value_raw[j].channel.match(channelId + ' [(]speed[)]') || results.histdata.item[i].value_raw[j].channel == channelId) {\r\n                                        v = Number(results.histdata.item[i].value_raw[j].text);\r\n                                      }\r\n                                    }\r\n                                } else if (results.histdata.item[i].value_raw) {\r\n                                     v = Number(results.histdata.item[i].value_raw.text);\r\n                                }\r\n                                result.push([v, dt]);\r\n                            }\r\n                            return result;\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        \r\n        /**\r\n         * Retrieve messages for a given sensor.\r\n         * \r\n         * @param from Earliest time in range\r\n         * @param to Latest time in range\r\n         * @sensorId Numeric ID of Sensor \r\n         */\r\n        getMessages(from, to, sensorId) {\r\n         var method = \"table.json\";\r\n          var params = \"&content=messages&columns=objid,datetime,parent,type,name,status,message&id=\" + sensorId;\r\n          return this.performPRTGAPIRequest(method, params).then(function(messages) {\r\n            var events = [];\r\n            var time = 0;\r\n              _.each(messages, function(message) {\r\n                time = Math.round((message.datetime_raw - 25569) * 86400,0);\r\n                if (time > from && time < to) {\r\n                  events.push({\r\n                  time: time * 1000,\r\n                  title: message.status,\r\n                  text: '<p>' + message.parent + '(' + message.type + ') Message:<br>'+ message.message +'</p>'\r\n                  });\r\n                }\r\n              });\r\n              return events;\r\n            });\r\n        }\r\n    }\r\n    return PRTGAPI;\r\n}\r\n\r\n//register a new module\r\nangular.module('grafana.services').factory('PRTGAPIService', PRTGAPIService);\r\n"]}