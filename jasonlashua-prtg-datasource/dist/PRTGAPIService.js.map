{"version":3,"sources":["../src/PRTGAPIService.js"],"names":["PRTGAPIService","alertSrv","backendSrv","PRTGAPI","api_url","username","passhash","cacheTimeoutMinutes","url","lastId","cache","Date","now","hashValue","Promise","resolve","data","getCache","str","hash","length","i","chr","charCodeAt","a","slice","unixtime","d","s","getFullYear","pad","getMonth","getDate","getHours","getMinutes","getSeconds","join","method","params","queryString","options","inCache","setCache","datasourceRequest","then","response","reject","message","groups","devices","sensors","channels","values","sensordata","messages","Version","XMLXform","console","log","error","status","statusText","performPRTGAPIRequest","groupFilter","deviceFilter","items","queryStr","invert","filterItems","match","_","trim","split","push","filter","findItem","item","group","device","sensor","name","utils","isRegex","rex","buildRegex","result","test","includes","performGroupSuggestQuery","filterQuery","hostFilter","getGroups","filters","each","filteredGroups","performDeviceSuggestQuery","sensorFilter","getHosts","hosts","host","performSensorSuggestQuery","getSensors","promises","map","objid","all","channel","sensor_raw","flatten","channelFilter","invertChannelFilter","getAllItems","target","getItems","dateFrom","dateTo","hours","avg","getPRTGDate","history","datetime","value","results","statusid","histdata","rCnt","v","prtgDate","datetime_raw","dt","value_raw","j","Number","text","from","to","sensorId","events","time","Math","round","title","parent","type","angular","module","factory"],"mappings":"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","file":"PRTGAPIService.js","sourcesContent":["import angular from 'angular';\r\nimport _ from 'lodash';\r\nimport * as utils from './utils';\r\nimport { XMLXform } from './xmlparser';\r\n/**\r\n * PRTG API Service\r\n * Implements the high level functions that process data from PRTG\r\n */\r\n\r\n/** @ngInject */\r\nfunction PRTGAPIService(alertSrv, backendSrv) {\r\n    \r\n    class PRTGAPI {\r\n        constructor (api_url, username, passhash, cacheTimeoutMinutes) {\r\n          this.url              = api_url;\r\n          this.username         = username;\r\n          this.passhash         = passhash;\r\n          this.lastId           = false;\r\n          this.cache            = {};\r\n          this.cacheTimeoutMinutes = cacheTimeoutMinutes;\r\n          this.alertSrv         = alertSrv;\r\n          this.backendSrv       = backendSrv;\r\n          \r\n        }\r\n        \r\n        /**\r\n         * Tests whether a url has been stored in the cache.\r\n         * Returns boolean true | false\r\n         */\r\n        inCache(url) {\r\n            if ((Date.now() - this.cache[this.hashValue(url)]) > (this.cacheTimeoutMinutes * 60 * 1000)) {\r\n                return false;\r\n            }\r\n            if (this.cache[this.hashValue(url)]) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        \r\n        /**\r\n        * retrieves a cached data result from the cache\r\n        *\r\n        * @param  url the URL of the request\r\n        * @return promise\r\n        */\r\n        getCache(url)    {\r\n            return Promise.resolve(this.cache[this.hashValue(url)]);\r\n        }\r\n        \r\n        /**\r\n        * stores a data result in the cache\r\n        *\r\n        * @param  url the URL of the request\r\n        * @param  data the response.data object of the request\r\n        * @return promise\r\n        */\r\n        setCache(url, data)    {\r\n            this.cache[this.hashValue(url)] = data;\r\n            return this.getCache(url);\r\n        }\r\n        \r\n        /**\r\n        * simple clone of a java hash value\r\n        * Kevin \"Pancake\" (http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/)\r\n        *\r\n        * @param  e string to hash\r\n        * @return int32\r\n        */\r\n        hashValue(str) {\r\n            var hash = 0;\r\n            if (str.length === 0) return hash;\r\n            for (var i = 0; i < str.length; i++) {\r\n                var chr = str.charCodeAt(i);\r\n                hash = ((hash<<5)-hash)+chr;\r\n                hash = hash & hash; // Convert to 32bit integer\r\n            }\r\n            return hash;\r\n        }\r\n        \r\n        /**\r\n         * pad date parts and optionally add one\r\n         */\r\n        pad(i,a)\t{\r\n            if (a) return (\"0\" + (i + 1)).slice(-2);\r\n            return (\"0\" + i).slice(-2);\r\n        }\r\n        \r\n        /**\r\n        * convert a UNIX timestamp into a PRTG date string for queries\r\n        * YYYY-MM-DD-HH-MM-SS\r\n        */\r\n        getPRTGDate(unixtime) \t{\r\n            var d = new Date(unixtime * 1000);\r\n            var s = [d.getFullYear(), this.pad(d.getMonth(),true), this.pad(d.getDate()), this.pad(d.getHours()), this.pad(d.getMinutes()), this.pad(d.getSeconds())];\r\n            return s.join(\"-\");\r\n        }\r\n\t\r\n        /**\r\n         * Request data from PRTG API\r\n         *\r\n         * @param  method the API method (e.g., table.json)\r\n         * @param  params HTTP query string query parameters\r\n         * @return promise\r\n         */\r\n        performPRTGAPIRequest(method, params) {\r\n            var queryString = 'username=' + this.username + '&passhash=' + this.passhash + '&' + params;\r\n            var options = {\r\n                method: 'GET',\r\n                url: this.url + '/' + method + '?' + queryString\r\n            };\r\n            \r\n            if (this.inCache(options.url)) {\r\n              return this.getCache(options.url);\r\n            } else {\r\n              return this.setCache(options.url, this.backendSrv.datasourceRequest(options)\r\n                .then(response => {\r\n                    if (!response.data) {\r\n                        return Promise.reject({message: \"Response contained no data\"});\r\n                    } \r\n                    \r\n                    if (response.data.groups) {\r\n                      return response.data.groups;\r\n                    }\r\n                    else if (response.data.devices) {\r\n                      return response.data.devices;\r\n                    }\r\n                    else if (response.data.sensors) {\r\n                      return response.data.sensors;\r\n                    }\r\n                    else if (response.data.channels) {\r\n                      return response.data.channels;\r\n                    }\r\n                    else if (response.data.values) {\r\n                      return response.data.values;\r\n                    }\r\n                    else if (response.data.sensordata) {\r\n                      return response.data.sensordata;\r\n                    }\r\n                    else if (response.data.messages) {\r\n                      return response.data.messages;\r\n                    }\r\n                    else if (response.data.Version) { //status request\r\n                      return response.data;\r\n                    } else {  //All else is XML from table.xml so throw it into the transformer and get JSON back.\r\n                      if (response.data == \"Not enough monitoring data\") {\r\n                        //Fixes Issue #5 - reject the promise with a message. The message is displayed instead of an uncaught exception.\r\n                        return Promise.reject({message: \"Not enough monitoring data.\\n\\nRequest:\\n\" + params + \"\\n\"});\r\n                      }\r\n                      if (response.data.length > 200) {\r\n                        return new XMLXform(method, response.data);\r\n                      } else {\r\n                        console.log(\"Short Response! :( \\n\" + response.data);\r\n                        return {};\r\n                      } \r\n                    }\r\n              }, error => {\r\n                return Promise.reject(error.status + \": \" + error.statusText);\r\n              }));\r\n            }   \r\n        }\r\n    \r\n        getVersion() {\r\n            return this.performPRTGAPIRequest('status.json').then(function (response) {\r\n                if (!response)\r\n                {\r\n                  return \"ERROR. No response.\";\r\n                } else {\r\n                  return response.Version;\r\n                }\r\n            });\r\n        }\r\n    \r\n        /**\r\n         * Authenticate to the PRTG interface\r\n         * not implemented yet (pass username/pass as query string/POST data)\r\n         */\r\n        performPRTGAPILogin() {\r\n            var username = this.username;\r\n            var passhash = this.passhash;\r\n            var options = {\r\n                method: 'GET',\r\n                url: this.url + \"/getstatus.htm?id=0&username=\" + username + \"&passhash=\" + passhash\r\n            };\r\n            return this.backendSrv.datasourceRequest(options).then(response => {\r\n                this.passhash = response;\r\n                return response;\r\n            });\r\n        }\r\n    \r\n        /**\r\n         * Query API for list of groups\r\n         *\r\n         * @return promise - JSON result set\r\n         */\r\n        performGroupSuggestQuery() {\r\n            var params = 'content=groups&columns=objid,group,probe,tags,active,status,message,priority';\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n    \r\n        /**\r\n         * Query API for list of devices\r\n         *\r\n         * @return promise - JSON result set\r\n         */\r\n        performDeviceSuggestQuery(groupFilter) {\r\n            var params = 'content=devices&columns=objid,device,group,probe,tags,active,status,message,priority';\r\n            if (groupFilter) {\r\n                params += ',group' + groupFilter;\r\n            }\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n    \r\n        /**\r\n         * Query API for list of sensors bound to a given device\r\n         *\r\n         * @return promise - JSON result set\r\n         */\r\n        performSensorSuggestQuery(deviceFilter) {\r\n            var params = 'content=sensors&columns=objid,sensor,device,group,probe,tags,active,status,message,priority' + deviceFilter;\r\n            return this.performPRTGAPIRequest('table.json', params);\r\n        }\r\n    \r\n \r\n        filterQuery(items, queryStr, invert = false) {\r\n            /**\r\n             * group device sensor includes properties:\r\n             * objid: num\r\n             * sensor: Name\r\n             * device: Device name\r\n             * group: Group name\r\n             * tags: comma separated\r\n             * active: true|false\r\n             * active_raw: -1 for true? wtf\r\n             * status: Status text\r\n             * status_raw: number\r\n             * message: html message\r\n             * message_raw: text message\r\n             * priority: number 1-5\r\n             */\r\n            var filterItems = [];\r\n            if (queryStr.match(/{[^{}]+}/g)) {\r\n                filterItems = _.trim(queryStr, '{}').split(',');\r\n            } else {\r\n                filterItems.push(queryStr);\r\n            }\r\n            return _.filter(items, item => {\r\n                \r\n                var findItem;\r\n                if (item.group && !item.device) {\r\n                    findItem = item.group;\r\n                } else if (item.device && !item.sensor) {\r\n                    findItem = item.device;\r\n                } else if (item.sensor && !item.name) {\r\n                    findItem = item.sensor;\r\n                } else if (item.name) {\r\n                    //console.log(\"FILTER: item.name \" + JSON.stringify(item,'',4));\r\n                    findItem = item.name;\r\n                } else {\r\n                    return false;\r\n                }\r\n                if (utils.isRegex(queryStr)) {\r\n                    var rex = utils.buildRegex(queryStr);\r\n                    var result = rex.test(findItem);\r\n                    if (invert) {\r\n                        return !result;\r\n                    }\r\n                    return result;\r\n                }\r\n                if (filterItems.length === 0) {\r\n                    return true;\r\n                }\r\n                if (invert) {\r\n                    return !filterItems.includes(findItem);\r\n                }\r\n                //console.log(\"FILTERITEMS: \" + JSON.stringify(filterItems,'',4));\r\n                //console.log(\"FINDITEM: \" + JSON.stringify(findItem,'',4));\r\n                return filterItems.includes(findItem);\r\n            });\r\n        }\r\n \r\n        getGroups(groupFilter = '/.*/') {\r\n            console.log(\"getGroups('\" + groupFilter + \"')\");\r\n            return this.performGroupSuggestQuery().then(groups => {\r\n                return this.filterQuery(groups, groupFilter);\r\n            });\r\n        }\r\n        \r\n        getHosts(groupFilter = '/.*/', hostFilter = '/.*/') {\r\n            return this.getGroups(groupFilter)\r\n            .then(filteredGroups => {\r\n                var filters = []; \r\n                _.each(filteredGroups, group => {\r\n                    filters.push('filter_group=' + group.group);\r\n                });\r\n                return this.performDeviceSuggestQuery(\"&\" + filters.join('&')).then(devices => {\r\n                    return this.filterQuery(devices, hostFilter);\r\n                });\r\n            });\r\n        }\r\n        \r\n        getSensors (groupFilter = '/.*/', hostFilter = '/.*/', sensorFilter = '/.*/') {\r\n            return this.getHosts(groupFilter, hostFilter).then(hosts => {\r\n                var filters = [];\r\n                _.each(hosts, host => {\r\n                    filters.push('filter_device=' + host.device);\r\n                });\r\n                return this.performSensorSuggestQuery(\"&\" + filters.join('&')).then(sensors => {\r\n                    return this.filterQuery(sensors, sensorFilter);\r\n                });\r\n            });\r\n        }\r\n\r\n        getAllItems(groupFilter = '/.*/', hostFilter = '/.*/', sensorFilter = '/.*/') {\r\n            return this.getSensors(groupFilter, hostFilter, sensorFilter).then(sensors => {\r\n                \r\n                /**\r\n                 * In this context, if i simply iterate an array with _.each and then execute performPRTGAPIRequest, even\r\n                 * though the returned object is a promise which can be used in a chain, the execution falls outside of the existing\r\n                 * promise chain and thus executs asynchronously. To keep everything in the same execution context, create a\r\n                 * promise array for each object, then execute them in context.\r\n                 */\r\n                var promises = _.map(sensors, sensor => {\r\n                    var params = 'content=channels&columns=sensor,name&id=' + sensor.objid;\r\n                    return this.performPRTGAPIRequest('table.json', params)\r\n                        .then(channels => {\r\n                            /**\r\n                             * Create an object that contains all of the information necessary to query this metric.\r\n                             * This information will be used at render time to group the datapoints and name them.\r\n                             */\r\n                            return Promise.all(_.map(channels, channel => {\r\n                                channel.sensor = sensor.objid;\r\n                                channel.sensor_raw = sensor.sensor;\r\n                                channel.device = sensor.device;\r\n                                channel.group = sensor.group;\r\n                                channel.channel = channel.name;\r\n                                return channel;\r\n                            }));\r\n                        });\r\n                });\r\n                return Promise.all(promises).then(_.flatten);\r\n            });\r\n        }\r\n    \r\n        getItems(groupFilter, deviceFilter, sensorFilter, channelFilter, invertChannelFilter = false) {\r\n            return this.getAllItems(groupFilter, deviceFilter, sensorFilter).then(items => {\r\n                return this.filterQuery(items, channelFilter, invertChannelFilter);\r\n                //return _.filter(items, item => {\r\n                //    return this.filterMatch(item.name, channelFilter, invertChannelFilter);\r\n                //});\r\n            });\r\n        }\r\n        getItemsFromTarget(target) {\r\n            /*\r\n             * Flow: is group filter present?\r\n             * yes: Get groups(filter)\r\n             * no: get device\r\n             */\r\n            \r\n            if (target.options) {\r\n                if(target.options.invertChannelFilter) {\r\n                    return this.getItems(target.group.name, target.device.name, target.sensor.name, target.channel.name, true);\r\n                } else {\r\n                    return this.getItems(target.group.name, target.device.name, target.sensor.name, target.channel.name);\r\n                }\r\n            }\r\n            return this.getItems(target.group.name, target.device.name, target.sensor.name, target.channel.name);\r\n                \r\n        }\r\n    \r\n        /*\r\n         * Replaces getValues\r\n         */\r\n        getItemHistory(sensor, channel, dateFrom, dateTo) {\r\n            var hours = ((dateTo-dateFrom) / 3600);\r\n            var avg = 0;\r\n            if (hours > 12 && hours < 36) {\r\n                avg = \"300\";\r\n            } else if (hours > 36 && hours < 745) {\r\n                avg = \"3600\";\r\n            } else if (hours > 745) {\r\n                avg = \"86400\";\r\n            }\r\n        \r\n            var method = \"historicdata.xml\";\r\n            var params = \"id=\" + sensor + \"&sdate=\" + this.getPRTGDate(dateFrom) + \"&edate=\" + this.getPRTGDate(dateTo) + \"&avg=\" + avg + \"&pctshow=false&pctmode=false\";\r\n            /*\r\n             * Modified to read the \"statusid\" value, this can then be mapped via lookup table to a PRTG status type\r\n             * 1=Unknown, 2=Scanning, 3=Up, 4=Warning, 5=Down, 6=No Probe, 7=Paused by User, 8=Paused by Dependency,\r\n             * 9=Paused by Schedule, 10=Unusual, 11=Not Licensed, 12=Paused Until, 13=Down Acknowledged, 14=Down Partial\r\n             */\r\n            var history = [];\r\n            if (channel == 'Status') {\r\n                params = \"&id=\" + sensor;\r\n                return this.performPRTGAPIRequest('getsensordetails.json', params).then(results => {\r\n                    history.push({sensor:sensor, channel:\"Status\", datetime: Date.now(), value: results.statusid});\r\n                    return history;\r\n                });\r\n            } else {\r\n                return this.performPRTGAPIRequest(method, params).then(results => {\r\n                \r\n                    if (!results.histdata) {\r\n                        return history;\r\n                    }\r\n                    var rCnt = results.histdata.item.length;\r\n\r\n                    for (var i=0;i<rCnt;i++)\r\n                    {\r\n                        var v;\r\n                        var prtgDate = results.histdata.item[i].datetime_raw;\r\n                        var dt = new Date((prtgDate - (25569)) * 86400 * 1000);\r\n                        //var dt = Math.round((results.histdata.item[i].datetime_raw - 25568) * 86400,0) * 1000;\r\n                        if (results.histdata.item[i].value_raw && (results.histdata.item[i].value_raw.length > 0))\r\n                        {\r\n                            //FIXME: better way of dealing with multiple channels of same name\r\n                            //IE you select \"Traffic In\" but PRTG provides Volume AND Speed channels.\r\n                            for (var j = 0; j < results.histdata.item[i].value_raw.length; j++) {\r\n                              //workaround for SNMP Bandwidth Issue #3. Check for presence of (speed) suffix, and use that.\r\n                              if (results.histdata.item[i].value_raw[j].channel.match(channel + ' [(]speed[)]') || results.histdata.item[i].value_raw[j].channel == channel) {\r\n                                v = Number(results.histdata.item[i].value_raw[j].text);\r\n                              }\r\n                            }\r\n                        } else if (results.histdata.item[i].value_raw) {\r\n                             v = Number(results.histdata.item[i].value_raw.text);\r\n                        }\r\n                        history.push({sensor: sensor, channel: channel, datetime: dt, value: v});\r\n                    }\r\n                    return history;\r\n                });\r\n            }\r\n        }\r\n    \r\n        /**\r\n         * Retrieve messages for a given sensor.\r\n         * \r\n         * @param from Earliest time in range\r\n         * @param to Latest time in range\r\n         * @sensorId Numeric ID of Sensor \r\n         */\r\n        getMessages(from, to, sensorId) {\r\n         var method = \"table.json\";\r\n          var params = \"&content=messages&columns=objid,datetime,parent,type,name,status,message&id=\" + sensorId;\r\n          return this.performPRTGAPIRequest(method, params).then(function(messages) {\r\n            var events = [];\r\n            var time = 0;\r\n              _.each(messages, function(message) {\r\n                time = Math.round((message.datetime_raw - 25569) * 86400,0);\r\n                if (time > from && time < to) {\r\n                  events.push({\r\n                  time: time * 1000,\r\n                  title: message.status,\r\n                  text: '<p>' + message.parent + '(' + message.type + ') Message:<br>'+ message.message +'</p>'\r\n                  });\r\n                }\r\n              });\r\n              return events;\r\n            });\r\n        }\r\n    }\r\n    return PRTGAPI;\r\n}\r\n\r\n//register a new module\r\nangular.module('grafana.services').factory('PRTGAPIService', PRTGAPIService);\r\n"]}