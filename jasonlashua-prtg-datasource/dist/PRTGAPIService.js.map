{"version":3,"sources":["../src/PRTGAPIService.js"],"names":["PRTGAPIService","alertSrv","backendSrv","PRTGAPI","api_url","username","passhash","cacheTimeoutMinutes","url","lastId","cache","Date","now","hashValue","Promise","resolve","data","getCache","str","hash","length","i","chr","charCodeAt","a","slice","unixtime","d","s","getFullYear","pad","getMonth","getDate","getHours","getMinutes","getSeconds","join","method","params","queryString","options","inCache","setCache","datasourceRequest","then","response","reject","message","groups","devices","sensors","channels","values","sensordata","messages","Version","XMLXform","err","match","regex","res","exec","performPRTGAPIRequest","groupFilter","deviceFilter","sensorId","device","arr","p","_","map","getDeviceByName","sensor","getSensorByName","all","objid","name","concat","items","queryStr","filterItems","trim","split","push","filter","findItem","item","group","channel","utils","isRegex","rex","buildRegex","test","includes","filterStr","hostFilter","performGroupSuggestQuery","filteredGroups","filterQuery","filters","each","performDeviceSuggestQuery","sensorFilter","getHosts","hosts","host","performSensorSuggestQuery","getSensors","promises","sensor_raw","flatten","channelFilter","getAllItems","filterMatch","target","getItems","dateFrom","dateTo","hours","avg","getPRTGDate","result","statusid","results","dt","histdata","rCnt","v","prtgDate","datetime_raw","value_raw","j","Number","text","from","to","events","time","Math","round","title","status","parent","type","angular","module","factory"],"mappings":"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","file":"PRTGAPIService.js","sourcesContent":["import angular from 'angular';\nimport _ from 'lodash';\nimport * as utils from './utils';\nimport { XMLXform } from './xmlparser';\n/**\n * PRTG API Service\n * Implements the high level functions that process data from PRTG\n */\n\n/** @ngInject */\nfunction PRTGAPIService(alertSrv, backendSrv) {\n    \n    class PRTGAPI {\n        constructor (api_url, username, passhash, cacheTimeoutMinutes) {\n          this.url              = api_url;\n          this.username         = username;\n          this.passhash         = passhash;\n          this.lastId           = false;\n          this.cache            = {};\n          this.cacheTimeoutMinutes = cacheTimeoutMinutes;\n          this.alertSrv         = alertSrv;\n          this.backendSrv       = backendSrv;\n          \n        }\n        \n        /**\n         * Tests whether a url has been stored in the cache.\n         * Returns boolean true | false\n         */\n        inCache(url) {\n            if ((Date.now() - this.cache[this.hashValue(url)]) > (this.cacheTimeoutMinutes * 60 * 1000)) {\n                return false;\n            }\n            if (this.cache[this.hashValue(url)]) {\n                return true;\n            }\n            return false;\n        }\n        \n        /**\n        * retrieves a cached data result from the cache\n        *\n        * @param  url the URL of the request\n        * @return promise\n        */\n        getCache(url)    {\n            return Promise.resolve(this.cache[this.hashValue(url)]);\n        }\n        \n        /**\n        * stores a data result in the cache\n        *\n        * @param  url the URL of the request\n        * @param  data the response.data object of the request\n        * @return promise\n        */\n        setCache(url, data)    {\n            this.cache[this.hashValue(url)] = data;\n            return this.getCache(url);\n        }\n        \n        /**\n        * simple clone of a java hash value\n        * Kevin \"Pancake\" (http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/)\n        *\n        * @param  e string to hash\n        * @return int32\n        */\n        hashValue(str) {\n            var hash = 0;\n            if (str.length === 0) return hash;\n            for (var i = 0; i < str.length; i++) {\n                var chr = str.charCodeAt(i);\n                hash = ((hash<<5)-hash)+chr;\n                hash = hash & hash; // Convert to 32bit integer\n            }\n            return hash;\n        }\n        \n        /**\n         * pad date parts and optionally add one\n         */\n        pad(i,a)\t{\n            if (a) return (\"0\" + (i + 1)).slice(-2);\n            return (\"0\" + i).slice(-2);\n        }\n        \n        /**\n        * convert a UNIX timestamp into a PRTG date string for queries\n        * YYYY-MM-DD-HH-MM-SS\n        */\n        getPRTGDate(unixtime) \t{\n            var d = new Date(unixtime * 1000);\n            var s = [d.getFullYear(), this.pad(d.getMonth(),true), this.pad(d.getDate()), this.pad(d.getHours()), this.pad(d.getMinutes()), this.pad(d.getSeconds())];\n            return s.join(\"-\");\n        }\n\t\n        /**\n         * Request data from PRTG API\n         *\n         * @param  method the API method (e.g., table.json)\n         * @param  params HTTP query string query parameters\n         * @return promise\n         */\n        performPRTGAPIRequest(method, params) {\n            var queryString = 'username=' + this.username + '&passhash=' + this.passhash + '&' + params;\n            var options = {\n                method: 'GET',\n                url: this.url + '/' + method + '?' + queryString\n            };\n            \n            if (this.inCache(options.url)) {\n              return this.getCache(options.url);\n            } else {\n              return this.setCache(options.url, this.backendSrv.datasourceRequest(options)\n                .then(response => {\n                    if (!response.data) {\n                        return Promise.reject({message: \"Response contained no data\"});\n                    } \n                    \n                    if (response.data.groups) {\n                      return response.data.groups;\n                    }\n                    else if (response.data.devices) {\n                      return response.data.devices;\n                    }\n                    else if (response.data.sensors) {\n                      return response.data.sensors;\n                    }\n                    else if (response.data.channels) {\n                      return response.data.channels;\n                    }\n                    else if (response.data.values) {\n                      return response.data.values;\n                    }\n                    else if (response.data.sensordata) {\n                      return response.data.sensordata;\n                    }\n                    else if (response.data.messages) {\n                      return response.data.messages;\n                    }\n                    else if (response.data.Version) { //status request\n                      return response.data;\n                    } else {  //All else is XML from table.xml so throw it into the transformer and get JSON back.\n                      if (response.data == \"Not enough monitoring data\") {\n                        //Fixes Issue #5 - reject the promise with a message. The message is displayed instead of an uncaught exception.\n                        return Promise.reject({message: \"Not enough monitoring data.\\n\\nRequest:\\n\" + params + \"\\n\"});\n                      }\n                      return new XMLXform(method, response.data);\n                    }\n              }, err => {\n                if (err.data.match(/<error>/g)) {\n                  var regex = /<error>(.*)<\\/error>/g;\n                  var res = regex.exec(err.data);\n                  err.message = res[1];\n                } else {\n                  err.message = \"Unknown error: \" + err.data;\n                }\n                return Promise.reject(err);\n              }));\n            }   \n        }\n    \n        getVersion() {\n            return this.performPRTGAPIRequest('status.json').then(function (response) {\n                if (!response)\n                {\n                  return \"ERROR. No response.\";\n                } else {\n                  return response.Version;\n                }\n            });\n        }\n    \n        /**\n         * Authenticate to the PRTG interface\n         * not implemented yet (pass username/pass as query string/POST data)\n         */\n        performPRTGAPILogin() {\n            var username = this.username;\n            var passhash = this.passhash;\n            var options = {\n                method: 'GET',\n                url: this.url + \"/getstatus.htm?id=0&username=\" + username + \"&passhash=\" + passhash\n            };\n            return this.backendSrv.datasourceRequest(options).then(response => {\n                this.passhash = response;\n                return response;\n            });\n        }\n    \n        /**\n         * Query API for list of groups\n         *\n         * @return promise - JSON result set\n         */\n        performGroupSuggestQuery() {\n            var params = 'content=groups&columns=objid,group';\n            return this.performPRTGAPIRequest('table.json', params);\n        }\n    \n        /**\n         * Query API for list of devices\n         *\n         * @return promise - JSON result set\n         */\n        performDeviceSuggestQuery(groupFilter) {\n            var params = 'content=devices&columns=objid,device';\n            if (groupFilter) {\n                params += ',group' + groupFilter;\n            }\n            return this.performPRTGAPIRequest('table.json', params);\n        }\n    \n        /**\n         * Query API for list of sensors bound to a given device\n         *\n         * @return promise - JSON result set\n         */\n        performSensorSuggestQuery(deviceFilter) {\n            var params = 'content=sensors&columns=objid,sensor,device,group' + deviceFilter;\n            return this.performPRTGAPIRequest('table.json', params);\n        }\n    \n        /**\n         * Query API for list of channels bound to a given sensor\n         * the sensor Id is unique to each device\n         *\n         * @return promise - JSON result set\n         */\n        performChannelSuggestQuery(sensorId, device) {\n            var arr = [{\"device\": device}, {\"sensor\":sensorId}];\n            var p = [];\n            p = _.map(arr, a => {\n                if (a.device && typeof a.device == \"string\") {\n                     return this.getDeviceByName(a.device);\n                }\n                \n                if (a.sensor && typeof a.sensor == \"string\") {\n                    return this.getSensorByName(a.sensor,arr[0].device);\n                }\n                \n            });\n            \n            return Promise.all(p).then(a => {\n                var sensor = a[1][0].objid;\n                var params = 'content=channels&columns=objid,channel,sensor,name&id=' + sensor;\n                return this.performPRTGAPIRequest('table.json', params);\n            });\n        }\n    \n        /**\n         *  For Templating: Retrieve device ObjId by it's name.\n         */\n        getDeviceByName(name)    {\n            var params = 'content=devices&columns=objid,device&filter_device=' + name;\n            return this.performPRTGAPIRequest('table.json', params);\n        }\n\n        /**\n         *  For Templating: Retrieve Sensor ObjId by it's name and parent device ObjId\n         */\n        getSensorByName(name, device)    {\n            var params = 'content=sensors&columns=objid,device,sensor&filter_device=' + device;\n            if (name !== '*') {\n                params += '&filter_sensor=' + name;\n            }   \n            return this.performPRTGAPIRequest('table.json', params);\n        }\n    \n        /**\n         * For templating: Retrieve Channel id from its given name.\n         * Sensor ID (number) required.\n         */\n        getChannelByName(name, sensor) {\n            var params = 'content=channels&columns=objid,channel,channelid&id='+ sensor;\n            if (name !== \"*\") {\n                params = params.concat('&filter_channel=' + name);\n            }\n            return this.performPRTGAPIRequest('table.json', params);\n        }\n\n        filterQuery(items, queryStr) {\n            var filterItems = [];\n            if (queryStr.match(/{[^{}]+}/g)) {\n                filterItems = _.trim(queryStr, '{}').split(',');\n            } else {\n                filterItems.push(queryStr);\n            }\n            //console.log(\"filterQuery: Find item\\n\" + JSON.stringify(items,'',4) + \"\\n\\nfilterQuery: Find in array: \" + JSON.stringify(filterItems,'',4));\n            return _.filter(items, item => {\n                \n                var findItem;\n                if (item.group && !item.device) {\n                    //console.log(\"find in obj.group\");\n                    findItem = item.group;\n                } else if (item.device && !item.sensor) {\n                    //console.log(\"find in obj.device\");\n                    findItem = item.device;\n                } else if (item.sensor) {\n                   //console.log(\"find in obj.sensor\");\n                    findItem = item.sensor;\n                } else if (item.channel) {\n                    findItem = item.name;\n                } else {\n                    //console.log(\"find ? no usable keys! \" + JSON.stringify(item,'',4));\n                    return false;\n                }\n                if (utils.isRegex(queryStr)) {\n                    var rex = utils.buildRegex(queryStr);\n                    return rex.test(findItem);\n                }\n                if (filterItems.length === 0) {\n                    return true;\n                }\n                return filterItems.includes(findItem);\n            });\n        }\n            \n        \n        filterMatch(findItem, filterStr) {\n           //console.log('filterMatch: ' + JSON.stringify(findItem,'',4) + ', ' + filterStr);\n\n            if(utils.isRegex(filterStr)) {\n                var rex = utils.buildRegex(filterStr);\n                return rex.test(findItem);\n            } else {\n                return (findItem === filterStr);\n            }\n        }\n        \n        getHosts(groupFilter, hostFilter) {\n           ////console.log('PRTGAPIService: 328: getHosts(' + groupFilter + ', ' + hostFilter +')');\n            return this.performGroupSuggestQuery().then(groups => {\n                var filteredGroups = this.filterQuery(groups, groupFilter);\n                //console.log('3: getHosts: filteredGroups: ' + JSON.stringify(filteredGroups,'',4));\n                var filters = []; \n                _.each(filteredGroups, group => {\n                    filters.push('filter_group=' + group.group);\n                });\n               \n                return this.performDeviceSuggestQuery(\"&\" + filters.join('&')).then(devices => {\n                  // //console.log(\"filterquery(devices, \" + hostFilter + \")\");\n                    \n                    return this.filterQuery(devices, hostFilter);\n                });\n            });\n        }\n        \n        getSensors (groupFilter, hostFilter, sensorFilter) {\n            return this.getHosts(groupFilter, hostFilter).then(hosts => {\n                //console.log(\"Got hosts: \" + JSON.stringify(hosts, '', 4));\n                var filters = [];\n                _.each(hosts, host => {\n                    //console.log(\"getSensors: add filter element: \" + host.device);\n                    filters.push('filter_device=' + host.device);\n                });\n                return this.performSensorSuggestQuery(\"&\" + filters.join('&')).then(sensors => {\n                    return this.filterQuery(sensors, sensorFilter);\n                });\n            });\n        }\n\n        getAllItems(groupFilter, hostFilter, sensorFilter) {\n            return this.getSensors(groupFilter, hostFilter, sensorFilter).then(sensors => {\n                \n                /**\n                 * In this context, if i simply iterate an array with _.each and then execute performPRTGAPIRequest, even\n                 * though the returned object is a promise which can be used in a chain, the execution falls outside of the existing\n                 * promise chain and thus executs asynchronously. To keep everything in the same execution context, create a\n                 * promise array for each object, then execute them in context.\n                 */\n                var promises = _.map(sensors, sensor => {\n                    var params = 'content=channels&columns=objid,channel,sensor,name&id=' + sensor.objid;\n                    return this.performPRTGAPIRequest('table.json', params)\n                        .then(channels => {\n                            /**\n                             * Create an object that contains all of the information necessary to query this metric\n                             */\n                            return Promise.all(_.map(channels, channel => {\n                                channel.sensor = sensor.objid;\n                                channel.sensor_raw = sensor.sensor;\n                                channel.device = sensor.device;\n                                channel.group = sensor.group;\n                                return channel;\n                            }));\n                        });\n                });\n                return Promise.all(promises).then(_.flatten);\n            });\n        }\n    \n        getItems(groupFilter, deviceFilter, sensorFilter, channelFilter) {\n            return this.getAllItems(groupFilter, deviceFilter, sensorFilter).then(items => {\n                //return this.filterQuery(items, channelFilter);\n                return _.filter(items, item => {\n                    return this.filterMatch(item.name, channelFilter);\n                });\n            });\n        }\n        getItemsFromTarget(target) {\n            /*\n             * Flow: is group filter present?\n             * yes: Get groups(filter)\n             * no: get device\n             */\n            return this.getItems(target.group.name, target.device.name, target.sensor.name, target.channel.name);\n                \n        }\n    \n        /*\n         * Replaces getValues\n         */\n        getItemHistory(sensor, channel, dateFrom, dateTo) {\n            var hours = ((dateTo-dateFrom) / 3600);\n            var avg = 0;\n            if (hours > 12 && hours < 36) {\n                avg = \"300\";\n            } else if (hours > 36 && hours < 745) {\n                avg = \"3600\";\n            } else if (hours > 745) {\n                avg = \"86400\";\n            }\n        \n            var method = \"historicdata.xml\";\n            var params = \"id=\" + sensor + \"&sdate=\" + this.getPRTGDate(dateFrom) + \"&edate=\" + this.getPRTGDate(dateTo) + \"&avg=\" + avg + \"&pctshow=false&pctmode=false\";\n            /*\n             * Modified to read the \"statusid\" value, this can then be mapped via lookup table to a PRTG status type\n             * 1=Unknown, 2=Scanning, 3=Up, 4=Warning, 5=Down, 6=No Probe, 7=Paused by User, 8=Paused by Dependency,\n             * 9=Paused by Schedule, 10=Unusual, 11=Not Licensed, 12=Paused Until, 13=Down Acknowledged, 14=Down Partial\n             */\n            var result = [];\n            if (channel == 'Status') {\n                params = \"&id=\" + sensor;\n                return this.performPRTGAPIRequest('getsensordetails.json', params).then(results => {\n                    var statusid = results.statusid;\n                   filter(\"Status ID: \" + statusid);  \n                    var dt = Date.now();\n                    result.push([statusid, dt]);\n                    return result;\n                });\n            } else {\n                return this.performPRTGAPIRequest(method, params).then(results => {\n                \n                    if (!results.histdata) {\n                        return results;\n                    }\n                    var rCnt = results.histdata.item.length;\n\n                    for (var i=0;i<rCnt;i++)\n                    {\n                        var v;\n                        var prtgDate = results.histdata.item[i].datetime_raw;\n                        var dt = new Date((prtgDate - (25569)) * 86400 * 1000);\n                        //var dt = Math.round((results.histdata.item[i].datetime_raw - 25568) * 86400,0) * 1000;\n                        if (results.histdata.item[i].value_raw && (results.histdata.item[i].value_raw.length > 0))\n                        {\n                            //FIXME: better way of dealing with multiple channels of same name\n                            //IE you select \"Traffic In\" but PRTG provides Volume AND Speed channels.\n                            for (var j = 0; j < results.histdata.item[i].value_raw.length; j++) {\n                              //workaround for SNMP Bandwidth Issue #3. Check for presence of (speed) suffix, and use that.\n                              if (results.histdata.item[i].value_raw[j].channel.match(channel + ' [(]speed[)]') || results.histdata.item[i].value_raw[j].channel == channel) {\n                                v = Number(results.histdata.item[i].value_raw[j].text);\n                              }\n                            }\n                        } else if (results.histdata.item[i].value_raw) {\n                             v = Number(results.histdata.item[i].value_raw.text);\n                        }\n                        result.push([v, dt]);\n                    }\n                    return result;\n                });\n            }\n        }\n    \n        /**\n         * Retrieve messages for a given sensor.\n         * \n         * @param from Earliest time in range\n         * @param to Latest time in range\n         * @sensorId Numeric ID of Sensor \n         */\n        getMessages(from, to, sensorId) {\n         var method = \"table.json\";\n          var params = \"&content=messages&columns=objid,datetime,parent,type,name,status,message&id=\" + sensorId;\n          return this.performPRTGAPIRequest(method, params).then(function(messages) {\n            var events = [];\n            var time = 0;\n              _.each(messages, function(message) {\n                time = Math.round((message.datetime_raw - 25569) * 86400,0);\n                if (time > from && time < to) {\n                  events.push({\n                  time: time * 1000,\n                  title: message.status,\n                  text: '<p>' + message.parent + '(' + message.type + ') Message:<br>'+ message.message +'</p>'\n                  });\n                }\n              });\n              return events;\n            });\n        }\n    }\n    return PRTGAPI;\n}\n\n//register a new module\nangular.module('grafana.services').factory('PRTGAPIService', PRTGAPIService);\n"]}